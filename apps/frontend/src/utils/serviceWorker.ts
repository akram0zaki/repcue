import logger from './logger'
/**
 * Service Worker registration utilities for RepCue PWA
 * Implements secure service worker management following OWASP guidelines
 */

export interface SWUpdateInfo {
  updateAvailable: boolean;
  registration?: ServiceWorkerRegistration;
}

interface BeforeInstallPromptEvent extends Event {
  readonly platforms: string[];
  readonly userChoice: Promise<{
    outcome: 'accepted' | 'dismissed';
    platform: string;
  }>;
  prompt(): Promise<void>;
}

/**
 * Register service worker and handle updates
 * Only registers in production to avoid development conflicts
 */
export const registerServiceWorker = (): Promise<SWUpdateInfo> => {
  return new Promise((resolve) => {
    // Only register service worker in production
    if (!('serviceWorker' in navigator) || import.meta.env.DEV) {
  logger.log('üîß Service worker not registered in development mode');
      resolve({ updateAvailable: false });
      return;
    }

    window.addEventListener('load', async () => {
      try {
  logger.log('üöÄ Registering service worker...');
        
        // Use the service worker generated by Vite PWA plugin
        const registration = await navigator.serviceWorker.register('/sw.js', {
          scope: '/'
        });

  logger.log('‚úÖ Service worker registered successfully');

        // Check for updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          
          if (newWorker) {
            logger.log('üîÑ Service worker update found');
            
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed') {
                if (navigator.serviceWorker.controller) {
                  // New update available
                  logger.log('üì¶ New content available, refresh to update');
                  resolve({ 
                    updateAvailable: true, 
                    registration 
                  });
                } else {
                  // Content is cached for offline use
                  logger.log('üíæ Content is cached for offline use');
                  resolve({ 
                    updateAvailable: false, 
                    registration 
                  });
                }
              }
            });
          }
        });

        // Check if service worker is already controlling the page
        if (registration.active && !navigator.serviceWorker.controller) {
          window.location.reload();
        }

        resolve({ 
          updateAvailable: false, 
          registration 
        });

      } catch (error) {
  logger.error('‚ùå Service worker registration failed:', error);
        resolve({ updateAvailable: false });
      }
    });
  });
};

/**
 * Update service worker when new version is available
 * Securely handles the update process
 */
export const updateServiceWorker = (registration: ServiceWorkerRegistration): Promise<void> => {
  return new Promise((resolve, reject) => {
    if (!registration || !registration.waiting) {
      reject(new Error('No service worker waiting to update'));
      return;
    }

    const updateWorker = registration.waiting;

    // Listen for the controlling change event
    navigator.serviceWorker.addEventListener('controllerchange', () => {
  logger.log('üîÑ Service worker updated successfully');
      window.location.reload();
      resolve();
    });

    // Tell the waiting service worker to skip waiting and become active
    updateWorker.postMessage({ type: 'SKIP_WAITING' });
  });
};

/**
 * Check if the app is running in standalone mode (installed as PWA)
 */
export const isStandalone = (): boolean => {
  return window.matchMedia('(display-mode: standalone)').matches ||
         (window.navigator as { standalone?: boolean }).standalone === true;
};

/**
 * Force refresh the PWA by clearing all caches and reloading from server
 * This bypasses all service worker caches and forces fresh content
 */
export const forceRefreshFromServer = async (): Promise<void> => {
  try {
    logger.log('üîÑ Force refreshing PWA from server...');

    // Method 1: Clear all caches
    if ('caches' in window) {
      const cacheNames = await caches.keys();
      logger.log(`üóëÔ∏è Clearing ${cacheNames.length} cache(s):`, cacheNames);
      
      await Promise.all(
        cacheNames.map(cacheName => caches.delete(cacheName))
      );
      logger.log('‚úÖ All caches cleared');
    }

    // Method 2: Unregister service worker if present
    if ('serviceWorker' in navigator) {
      const registrations = await navigator.serviceWorker.getRegistrations();
      for (const registration of registrations) {
        logger.log('üö´ Unregistering service worker:', registration.scope);
        await registration.unregister();
      }
    }

    // Method 3: Hard reload from server
    logger.log('üîÉ Performing hard reload from server...');
    window.location.reload();
    
  } catch (error) {
    logger.error('‚ùå Force refresh failed:', error);
    // Fallback: regular hard reload
    window.location.reload();
  }
};

/**
 * Clear only PWA caches while keeping service worker active
 * Less disruptive than full force refresh
 */
export const clearPWACaches = async (): Promise<void> => {
  try {
    if ('caches' in window) {
      const cacheNames = await caches.keys();
      logger.log(`üßπ Clearing ${cacheNames.length} PWA cache(s)...`);
      
      await Promise.all(
        cacheNames.map(cacheName => caches.delete(cacheName))
      );
      
      logger.log('‚úÖ PWA caches cleared successfully');
    }
  } catch (error) {
    logger.error('‚ùå Cache clearing failed:', error);
    throw error;
  }
};

/**
 * Check for and apply service worker updates immediately
 */
export const forceUpdateServiceWorker = async (): Promise<void> => {
  try {
    if (!('serviceWorker' in navigator)) {
      throw new Error('Service worker not supported');
    }

    const registration = await navigator.serviceWorker.ready;
    
    logger.log('üîç Checking for service worker updates...');
    await registration.update();
    
    if (registration.waiting) {
      logger.log('üöÄ Activating waiting service worker...');
      registration.waiting.postMessage({ type: 'SKIP_WAITING' });
      
      // Wait for controller change
      return new Promise((resolve) => {
        navigator.serviceWorker.addEventListener('controllerchange', () => {
          logger.log('‚úÖ Service worker updated and activated');
          window.location.reload();
          resolve();
        });
      });
    } else {
      logger.log('‚ÑπÔ∏è No service worker updates available');
    }
  } catch (error) {
    logger.error('‚ùå Service worker update failed:', error);
    throw error;
  }
};

/**
 * Show install prompt for PWA
 */
export const setupInstallPrompt = (): Promise<boolean> => {
  return new Promise((resolve) => {
    let deferredPrompt: BeforeInstallPromptEvent | null = null;

    window.addEventListener('beforeinstallprompt', (e) => {
      // Prevent the mini-infobar from appearing on mobile
      e.preventDefault();
      deferredPrompt = e as BeforeInstallPromptEvent;
      
  logger.log('üí° PWA install prompt available');
      resolve(true);
    });

    // Handle install completion
    window.addEventListener('appinstalled', () => {
  logger.log('üéâ PWA was installed successfully');
      deferredPrompt = null;
    });

    // Timeout if no install prompt is available
    setTimeout(() => {
      if (!deferredPrompt) {
        resolve(false);
      }
    }, 3000);
  });
};
